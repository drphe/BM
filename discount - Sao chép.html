<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phân Tích Cổ Phiếu</title>
    <style>
        body {
	    font-family: Inter, Nunito Sans, Lexend, Noto Sans,Arial,  sans-serif;
	    font-size:14px;
            background-color: #fff;
            margin: 20px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background-color: #f4f4f9;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 400px;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 5px;
            text-align: center;
        }

        label {
            display: block;
            margin-top: 5px;
            font-weight: bold;
        }

        input {
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .input-group {
            display: flex;
            align-items: center;
        }

        .input-group span {
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            border-left: none;
            border-radius: 0 4px 4px 0;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 50%;
        }

        button:hover {
            background-color: #0056b3;
        }

        .result {
            margin-top: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 50px;
        }

        input#stockCode {
            text-transform: uppercase;
            /* Chuyển tự động thành chữ in hoa */
        }
    </style>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        table,
        th,
        td {
            border: 1px solid black;
        }

        th,
        td {
            padding: 8px;
            text-align: left;
        }
::-webkit-scrollbar-track {
	box-shadow: inset 0 0 0 grey;
	border-radius: 1px;
}

::-webkit-scrollbar-thumb {
	background: #ccc;
	border-radius: 10px
}

::-webkit-scrollbar {
	width: 5px;
	height: 5px;
	background: transparent;
}
    </style>
</head>

<body>
    <div class="container">
        <h1>Phân Tích Cổ Phiếu</h1>
        <label for="stockCode">Mã Cổ Phiếu</label>
        <input type="text" id="stockCode" value="VN-INDEX" placeholder="Nhập mã cổ phiếu...">
        <button onclick="analyzeStock()">Thống kê các mức chiết khấu</button>
        <div class="result" id="resultBox">Kết quả sẽ hiển thị tại đây...</div><br />
        <table id="resultsTable">
            <thead>
                <tr>
                    <th>Tạo đỉnh</th>
                    <th>Giá</th>
                    <th>Tạo đáy</th>
                    <th>Giá</th>
                    <th>Chiết khấu (%)</th>
                    <th>Hồi phục (%)</th>
                </tr>
            </thead>
            <tbody>
                <!-- Data will be populated here -->
            </tbody>
        </table>
    </div>


    <script>
        function analyzeStock() {
            // Lấy giá trị từ các ô nhập liệu
            const stockCode = document.getElementById("stockCode").value.trim().toUpperCase();

            // Kiểm tra đầu vào
            if (!stockCode || stockCode.length < 3) {
                document.getElementById("resultBox").innerText = "Vui lòng nhập mã cổ phiếu hợp lệ.";
                return;
            }

            // Xử lý dữ liệu 
            fetchData(stockCode);
        }
	analyzeStock();
	let ckht = ``;
        function formatTimestamp(timestamp) {
            // Chuyển đổi timestamp (giây) sang milliseconds
            const date = new Date(timestamp * 1000);

            // Lấy ngày, tháng và năm
            const day = String(date.getDate()).padStart(2, '0'); // Đảm bảo 2 chữ số
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Tháng bắt đầu từ 0
            const year = String(date.getFullYear()).slice(-2); // Lấy 2 chữ số cuối của năm

            // Trả về định dạng dd/mm/yy
            return `${day}/${month}/${year}`;
        }

        function getCurrentDate() {
            const t = new Date;
            return t.getFullYear() + "-" + String(t.getMonth() + 1)
                .padStart(2, "0") + "-" + String(t.getDate())
                .padStart(2, "0")
        }
        async function fetchData(code) {
            const apiUrl = "https://mastrade.masvn.com/api/v1/tradingview/history?symbol=" + code + "&resolution=1D&from=1420070400&to=" + parseInt(Date.parse(getCurrentDate()) / 1000);
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
        	var ohlc = [], closep = [];
                for (var i = 0; i < data.t.length; i += 1) {
                    let k = 1000;
                    ohlc.push({
                        "time": parseInt(data.t[i]),
                        "open": parseFloat(data.o[i]),
                        "high": parseFloat(data.h[i]),
                        "low": parseFloat(data.l[i]),
                        "close": parseFloat(data.c[i])
                    });
                    closep.push({
                        "time": data.t[i],
                        "value": parseFloat(data.c[i])
                    });
                }
                var drawdown = findRecoveries(closep);
                var sampleData = [],sampleData2 = [];
                for (let i = 1; i < drawdown.length; i++) {
                    sampleData.push(drawdown[i].drawdown)
                    sampleData2.push(drawdown[i].recover)
                }
                const ci = calculateConfidenceInterval(sampleData);
                const ci2 = calculateConfidenceInterval(sampleData2);
                renderResults(drawdown.slice(-10))
                const mockResult = `Kết quả thống kê cho mã: <b title="Số lần tạo đáy và hồi phục thành công">${code} (${drawdown.length})</b><br/>Mức chiết khấu trung bình là ${ci.mean.toFixed(2)}% [${ci.lowerBound.toFixed(2)}, ${ci.upperBound.toFixed(2)}].<br/>Mức hồi phục trung bình là ${ci2.mean.toFixed(2)}% [${ci2.lowerBound.toFixed(2)}, ${ci2.upperBound.toFixed(2)}]<br/> ${ckht}`;

                // Hiển thị kết quả
                document.getElementById("resultBox").innerHTML = mockResult;
            } catch (error) {
                console.error('There has been a problem with your fetch operation:', error);
                document.getElementById("resultBox").innerHTML = `Mã cổ phiếu không hợp lệ, hoặc lỗi không lấy được dữ liệu<br/> ${error}`;
            }
        }
	function calculateIntervalRecoverAfterDrawdown(data, currentDiscount){
		const filteredData = data.filter(item => item.drawdown >= currentDiscount); 
		const sortedRecoveries = filteredData.map(item => item.recover).sort((a, b) => a - b); 
		const percentileIndex = Math.ceil(0.1 * sortedRecoveries.length) - 1; 
		const recoveryAt80Percentile = sortedRecoveries[percentileIndex]; 
		return `Mức hồi phục với xác suất 90% là: ${recoveryAt80Percentile.toFixed(2)}%<i title="Số nhịp giảm lớn hơn hiện tại">(${filteredData.length})</i>`;
	}
        function calculateConfidenceInterval(data) {
            if (data.length === 0) return null; // Kiểm tra nếu mảng trống

            const n = data.length;
            const mean = data.reduce((sum, value) => sum + value, 0) / n;

            // Tính độ lệch chuẩn
            const variance = data.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / (n - 1);
            const standardDeviation = Math.sqrt(variance);

            // Sai số chuẩn
            const standardError = standardDeviation / Math.sqrt(n);

            // Giá trị Z cho mức tin cậy 95%
            const zScore = 1.96;

            // Khoảng tin cậy
            const marginOfError = zScore * standardError;
            const lowerBound = mean - marginOfError;
            const upperBound = mean + marginOfError;

            return {
                mean,
                lowerBound,
                upperBound,
                marginOfError,
            };
        }
function calculateMA(data, period) {
    return data.map((_, index) => {
        if (index < period - 1) return null;
        const slice = data.slice(index - period + 1, index + 1);
        const average = slice.reduce((sum, val) => sum + val, 0) / period;
        return average;
    });
}
        function findRecoveries(data) {
            const results = [];
		var ab = data.map(s=> s.value); var ma10 = calculateMA(ab,20);// tính MA10
            let peak = data[0].value; // Giá đỉnh ban đầu
            let tpeak = data[0].time; // Giá đỉnh ban đầu
            let trough = data[0].value; // Giá đáy ban đầu
            let ttrough = data[0].time; // Giá đáy ban đầu
            let inDecline = false; // Trạng thái đang sụt giảm, mặc định là không
            for (let i = 1; i < data.length; i++) {
                if (!inDecline) { // đang tăng
                    if (data[i].value < peak) { // Bắt đầu sụt giảm
                        inDecline = true;
                        trough = data[i].value;
                        ttrough = data[i].time;
                    } else {
                        peak = data[i].value; // Cập nhật đỉnh nếu vẫn tăng
                        tpeak = data[i].time;
                        inDecline = false;
                    }
                } else { // đang giảm 
                    if (trough > data[i].value) {
                        trough = data[i].value; // Cập nhật đáy nếu vẫn giảm
                        ttrough = data[i].time
                        inDecline = true;
                    } else {
                        if (data[i].value > peak) {
                            peak = data[i].value; // Cập nhật đỉnh nếu giá hồi vượt đỉnh (không có đợt giảm sâu)
                            tpeak = data[i].time;
                            inDecline = false;
                        } else {
				// điều kiện xác nhận hồi phục khi đáy ở dưới ma20 và giá hồi phục vượt được ma20
                            if (data[i].value > ma10[i] && trough < ma10[i]) { // giá vượt ngưỡng  phục hồi hoặc vượt MA20
                                const recoveryDate = data[i].time; // Thời điểm hồi phục
                                results.push({
                                    drawdown: (1 - trough / peak) * 100,
                                    start: peak,
                                    startDate: formatTimestamp(tpeak),
                                    bottom: trough,
                                    bottomDate: formatTimestamp(ttrough),
                                    recoveryDate: formatTimestamp(recoveryDate),
                                    recoveryPrice: data[i].value,
                                    recover: 0,
                                });
                                inDecline = false; // Xác nhận hồi phục
                                peak = data[i].value; // Reset đỉnh
                                tpeak = data[i].time; // Reset đỉnh
                            } else {
                                // chưa xác nhận đã hồi phục, tiếp tục giảm
                                inDecline = true;
                            }
                        }
                    }
                }
            }
		// lọc các đợt drawdown <2% do sideway nằm trong biên độ nhỏ
		const output = results.filter(item => item.drawdown > 2);
		// tính mức hồi phục bằng đỉnh mới- đáy cũ
            for (i = 0; i < output.length-1; i++) {
                output[i].recover = 100*output[i+1].start/output[i].bottom - 100;
            }
                output[output.length-1].recover = 100*peak/output[output.length-1].bottom - 100;// tính mức recover

		ckht='';//reset ckht;
		if(data[data.length-1].value < peak) {
			let gg = ((1- data[data.length-1].value/peak)*100).toFixed(2);
			ckht+=`Chiết khấu hiện tại: ${gg}% - Đỉnh ngày ${formatTimestamp(tpeak)}.<br/>${calculateIntervalRecoverAfterDrawdown(output,gg)}`;
		}
		if(data[data.length-1].value > trough) {
			ckht+=`<br/>Đã hồi phục từ đáy:  ${((data[data.length-1].value/trough-1)*100).toFixed(2)}% - Đáy ngày ${formatTimestamp(ttrough)}`;
		}

            return output;
        }
    </script>
    <script>
        function renderResults(results) {
            const tableBody = document.querySelector('#resultsTable tbody');
            tableBody.innerHTML = ''; // Clear existing table data
		results.reverse();
            // Loop through results array and add rows to the table
            results.forEach(result => {
                const row = document.createElement('tr');
                row.innerHTML = `
            <td>${result.startDate}</td>
            <td>${result.start.toFixed(0)}</td>
            <td>${result.bottomDate}</td>
            <td>${result.bottom.toFixed(0)}</td>
            <td>${result.drawdown.toFixed(2)}</td>
            <td>${result.recover.toFixed(2)}</td>
        `;
                tableBody.appendChild(row);
            });
        }
    </script>
</body>

</html>